# 简单动态字符串

- [简单动态字符串](#简单动态字符串)
  - [简介](#简介)
  - [应用](#应用)
  - [实现](#实现)
  - [SDS与C字符串的区别](#sds与c字符串的区别)
  - [API](#api)
  - [重点回顾](#重点回顾)

## 简介
- simple dynamic string, SDS
- C字符串只会作为字符串字面值用在一些无须对字符串值进行修改的地方
- 当 Redis 需要的不仅仅是一个字符串字面量， 而是一个可以被修改的字符串值时， Redis 就会使用 SDS 来表示字符串值

## 应用
- 来保存数据库中的字符串值
- 被用作缓冲区（buffer）： AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区


## 实现
```c
struct sdshdr
{
    int len;    //记录buf数组中已使用字节的数量
    int free;   //记录buf数组中未使用字节的数量
    char buf[]; //用于保存字符串的字节数组
};
```
- SDS中保存空字符的1字节空间不计算在len属性中，并且会为空字符分配额外的1字节空间，这使得可以直接重用一部分C字符串函数库里面的函数

## SDS与C字符串的区别
- C语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串， 并且字符数组的最后一个元素总是空字符 '\0',虽然简单，但是并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求
- 获取字符串长度的时间复杂度
  - C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) 
  - SDS 在 len 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1)
- 杜绝缓冲区溢出
  - 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题
- 减少修改字符串时带来的内存重分配次数
  - 每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作
  - SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节
  - 空间预分配,用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间,可以减少连续执行字符串增长操作所需的内存重分配次数
    - 如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同
    - 如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间
    - 在扩展 SDS 空间之前， SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配。
  - 惰性空间释放
    - 优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用
    - SDS 也提供了相应的 API ， 让我们可以在有需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费
- 二进制安全
  - C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾
  - SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样
- SDS 可以重用一部分 < string.h \> 库定义的函数
 
## API
函数|作用|时间复杂度
|:---:|:--:|:----:|
sdsnew|创建一个给定C字符串的SDS|O(N),N为给定字符串的长度
sdsempty|创建一个不包含内容的SDS|O(1)
sdsfree|释放给定的SDS|O(N),N为给定字符串的长度
sdslen|返回已使用空间字节数|O(1)
sdsavail|返回未使用空间字节数|O(1)
sdsdup|创建一个给定的副本|O(N),N为给定字符串的长度
sdsclear|清空字符串|O(1)
sdscat|将给定的C字符串拼接到末尾|O(N),N为被拼接C字符串的长度
sdscatsds|将给定的SDS字符串拼接到末尾|O(N),N为被拼接SDS字符串的长度
sdscpy|将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。|	O(N) ， N 为被复制 C 字符串的长度。
sdsgrowzero|用空字符将 SDS 扩展至给定长度。	|O(N) ， N 为扩展新增的字节数。
sdsrange|保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。|	O(N) ， N 为被保留数据的字节数。
sdstrim|接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。|O(M*N) ， M 为 SDS 的长度， N 为给定 C 字符串的长度。
sdscmp|对比两个 SDS 字符串是否相同。|O(N) ， N 为两个 SDS 中较短的那个 SDS 的长度

## 重点回顾
- Redis 只会使用 C 字符串作为字面量， 在大多数情况下， Redis 使用 SDS （Simple Dynamic String，简单动态字符串）作为字符串表示。
- 比起 C 字符串， SDS 具有以下优点：
  - 常数复杂度获取字符串长度。
  - 杜绝缓冲区溢出。
  - 减少修改字符串长度时所需的内存重分配次数。
  - 二进制安全。
  - 兼容部分 C 字符串函数。