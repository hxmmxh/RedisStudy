服务器
---------------------------
- [简介](#简介)
- [命令请求的执行过程](#命令请求的执行过程)
  - [发送命令请求](#发送命令请求)
  - [读取命令请求](#读取命令请求)
  - [命令执行器（1）：查找命令实现](#命令执行器1查找命令实现)
  - [命令执行器（2）：执行预备操作](#命令执行器2执行预备操作)
  - [命令执行器（3）：调用命令的实现函数](#命令执行器3调用命令的实现函数)
  - [命令执行器（4）：执行后续工作](#命令执行器4执行后续工作)
- [serverCron函数](#servercron函数)
  - [1. 更新服务器时间缓存](#1-更新服务器时间缓存)
  - [2. 更新LRU时间](#2-更新lru时间)
  - [3. 更新服务器每秒执行命令数](#3-更新服务器每秒执行命令数)
  - [4. 更新服务器内存峰值记录](#4-更新服务器内存峰值记录)
  - [5. 处理SIGTERM信号](#5-处理sigterm信号)
  - [6. 管理客户端资源](#6-管理客户端资源)
  - [7. 管理数据库资源](#7-管理数据库资源)
  - [8. 执行被延迟的BGREWRITEAOF](#8-执行被延迟的bgrewriteaof)
  - [9. 检查持久化操作的运行状态](#9-检查持久化操作的运行状态)
  - [10. 将AOF缓冲区中的内容写入到AOF文件](#10-将aof缓冲区中的内容写入到aof文件)
  - [11. 关闭异步客户端](#11-关闭异步客户端)
  - [12. 增加cronloops计数器的值](#12-增加cronloops计数器的值)
- [初始化服务器](#初始化服务器)
  - [初始化服务器状态结构](#初始化服务器状态结构)
  - [载入配置结构](#载入配置结构)
  - [初始化服务器数据结构](#初始化服务器数据结构)
  - [还原数据库状态](#还原数据库状态)
  - [执行时间循环](#执行时间循环)

# 简介

- Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令产生的数据，并通过资源管理来维持服务器自身的运转
- 使用文件事件处理器来处理命令请求和返回命令回复。
- 使用时间事件处理器来执行 serverCron 函数
- 使用数据库来保存键值对数据，键值对依然会是各种不同类型的对象。
- 使用 RDB 持久化模块和 AOF 持久化模块来执行持久化工作。
- 使用发布与订阅模块来执行 PUBLISH 、 SUBSCRIBE 等命令。
- 使用复制模块来进行节点的复制工作。
- 续使用 Lua 脚本环境来执行客户端输入的 Lua 脚本。

# 命令请求的执行过程

## 发送命令请求

- 当用户在客户端中键入一个命令请求时， 客户端会将这个命令请求转换成协议格式， 然后通过连接到服务器的套接字， 将协议格式的命令请求发送给服务器

## 读取命令请求

- 当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时， 服务器将调用命令请求处理器来执行以下操作：
  - 读取套接字中协议格式的命令请求， 并将其保存到客户端状态的输入缓冲区里面。
  - 对输入缓冲区中的命令请求进行分析， 提取出命令请求中包含的命令参数， 以及命令参数的个数， 然后分别将参数和参数个数保存到客户端状态的 argv 属性和 argc 属性里面。
  - 调用命令执行器， 执行客户端指定的命令。

## 命令执行器（1）：查找命令实现

- 命令执行器要做的第一件事就是根据客户端状态的 argv[0] 参数， 在命令表（command table）中查找参数所指定的命令， 并将找到的命令保存到客户端状态的 cmd 属性里面。
- 命令表使用的是大小写无关的查找算法， 无论输入的命令名字是大写、小写或者混合大小写， 只要命令的名字是正确的， 就能找到相应的 redisCommand 结构
- 命令表是一个字典， 字典的键是一个个命令名字，比如 "set" 、 "get" 、 "del" ，等等； 而字典的值则是一个个 redisCommand 结构， 每个 redisCommand 结构记录了一个 Redis 命令的实现信息
```c
struct redisCommand 
{
    // 命令名字
    char *name;
    // 指向命令的实现函数
    redisCommandProc *proc;
    // 	命令参数的个数，用于检查命令请求的格式是否正确。 如果这个值为负数 -N ，那么表示参数的数量大于等于 N 。 注意命令的名字本身也是一个参数
    int arity;
    // 字符串表示的 FLAG，记录了命令的属性，一个字符表示一个属性
    char *sflags; 
    // 对 sflags 标识进行分析得出的二进制标识， 由程序自动生成。 服务器对命令标识进行检查时使用的都是 flags 属性而不是 sflags 属性， 因为对二进制标识的检查可以方便地通过 & 、 ^ 、 ~ 等操作来完成
    int flags;  

    // 从命令中判断命令的键参数。在 Redis 集群转向时使用。
    redisGetKeysProc *getkeys_proc;


    // 指定哪些参数是 key
    int firstkey; /* The first argument that's a key (0 = no keys) */
    int lastkey;  /* The last argument that's a key */
    int keystep;  /* The step between first and last key */

    // 统计信息
    // microseconds 记录了命令执行耗费的总毫秒数
    // calls 是命令被执行的总次数
    long long microseconds, calls;
};
```

-  sflags 属性可以使用的标识值


标识|意义|带有这个标识的命令
|----|---|-----|
w|这是一个写入命令，可能会修改数据库。|SET 、 RPUSH 、 DEL ，等等。
r|这是一个只读命令，不会修改数据库。|GET 、 STRLEN 、 EXISTS ，等等。
m|这个命令可能会占用大量内存， 执行之前需要先检查服务器的内存使用情况， 如果内存紧缺的话就禁止执行这个命令。|SET 、 APPEND 、 RPUSH 、 LPUSH 、 SADD 、 SINTERSTORE ，等等。
a|这是一个管理命令。|SAVE 、 BGSAVE 、 SHUTDOWN ，等等。
p|这是一个发布与订阅功能方面的命令。|PUBLISH 、 SUBSCRIBE 、 PUBSUB ，等等。
s|这个命令不可以在 Lua 脚本中使用。|BRPOP 、 BLPOP 、 BRPOPLPUSH 、 SPOP ，等等。
R|这是一个随机命令， 对于相同的数据集和相同的参数， 命令返回的结果可能不同。|SPOP 、 SRANDMEMBER 、 SSCAN 、 RANDOMKEY ，等等。
S|当在 Lua 脚本中使用这个命令时， 对这个命令的输出结果进行一次排序， 使得命令的结果有序。|SINTER 、 SUNION 、 SDIFF 、 SMEMBERS 、 KEYS ，等等。
l|这个命令可以在服务器载入数据的过程中使用。|INFO 、 SHUTDOWN 、 PUBLISH ，等等。
t|这是一个允许从服务器在带有过期数据时使用的命令。|SLAVEOF 、 PING 、 INFO ，等等。
M|这个命令在监视器（monitor）模式下不会自动被传播（propagate）。|EXEC

## 命令执行器（2）：执行预备操作

-  服务器已经将执行命令所需的命令实现函数（保存在客户端状态的 cmd 属性）、参数（保存在客户端状态的 argv 属性）、参数个数（保存在客户端状态的 argc 属性）都收集齐了， 但是在真正执行命令之前， 程序还需要进行一些预备操作， 从而确保命令可以正确、顺利地被执行
-  检查客户端状态的 cmd 指针是否指向 NULL ， 如果是的话， 那么说明用户输入的命令名字找不到相应的命令实现， 服务器不再执行后续步骤， 并向客户端返回一个错误
-  根据客户端 cmd 属性指向的 redisCommand 结构的 arity 属性， 检查命令请求所给定的参数个数是否正确， 当参数个数不正确时， 不再执行后续步骤， 直接向客户端返回一个错误
-  检查客户端是否已经通过了身份验证， 未通过身份验证的客户端只能执行 AUTH 命令， 如果未通过身份验证的客户端试图执行除 AUTH 命令之外的其他命令， 那么服务器将向客户端返回一个错误。
-  如果服务器打开了 maxmemory 功能， 那么在执行命令之前， 先检查服务器的内存占用情况， 并在有需要时进行内存回收， 从而使得接下来的命令可以顺利执行。 如果内存回收失败， 那么不再执行后续步骤， 向客户端返回一个错误
-  如果服务器上一次执行 BGSAVE 命令时出错， 并且服务器打开了 stop-writes-on-bgsave-error 功能， 而且服务器即将要执行的命令是一个写命令， 那么服务器将拒绝执行这个命令， 并向客户端返回一个错误
-  如果客户端当前正在用 SUBSCRIBE 命令订阅频道， 或者正在用 PSUBSCRIBE 命令订阅模式， 那么服务器只会执行客户端发来的 SUBSCRIBE 、 PSUBSCRIBE 、 UNSUBSCRIBE 、 PUNSUBSCRIBE 四个命令， 其他别的命令都会被服务器拒绝。
-  如果服务器正在进行数据载入， 那么客户端发送的命令必须带有 l 标识（比如 INFO 、 SHUTDOWN 、 PUBLISH ，等等）才会被服务器执行， 其他别的命令都会被服务器拒绝
-  如果服务器因为执行 Lua 脚本而超时并进入阻塞状态， 那么服务器只会执行客户端发来的 SHUTDOWN nosave 命令和 SCRIPT KILL 命令， 其他别的命令都会被服务器拒绝。
-  如果客户端正在执行事务， 那么服务器只会执行客户端发来的 EXEC 、 DISCARD 、 MULTI 、 WATCH 四个命令， 其他命令都会被放进事务队列中。
-  如果服务器打开了监视器功能， 那么服务器会将要执行的命令和参数等信息发送给监视器


## 命令执行器（3）：调用命令的实现函数

- 被调用的命令实现函数会执行指定的操作， 并产生相应的命令回复， 这些回复会被保存在客户端状态的输出缓冲区里面（buf 属性和 reply 属性）， 之后实现函数还会为客户端的套接字关联命令回复处理器， 这个处理器负责将命令回复返回给客户端。
- 当命令回复发送完毕之后， 回复处理器会清空客户端状态的输出缓冲区， 为处理下一个命令请求做好准

## 命令执行器（4）：执行后续工作

- 如果服务器开启了慢查询日志功能， 那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。
- 根据刚刚执行命令所耗费的时长， 更新被执行命令的 redisCommand 结构的 milliseconds 属性， 并将命令的 redisCommand 结构的 calls 计数器的值增一。
- 如果服务器开启了 AOF 持久化功能， 那么 AOF 持久化模块会将刚刚执行的命令请求写入到 AOF 缓冲区里面。
- 如果有其他从服务器正在复制当前这个服务器， 那么服务器会将刚刚执行的命令传播给所有从服务器。


# serverCron函数

- Redis服务器中的serverCron函数默认每隔100毫秒执行一次，负责管理服务器的资源，并保持服务器自身的良好运转
  
## 1. 更新服务器时间缓存

- 每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存
- 这两个属性记录的时间精确度不高，因此
  - 只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间等对时间精确度不高的功能上使用这两个属性
  - 对于为键设置过期时间，添加慢查询日志这种需要高精确度时间的功能来说，还是会再次执行系统调用

## 2. 更新LRU时间

- 服务器状态中的lruclock属性保存了服务器的LRU时钟，用于计算键的空转时间
- 默认每10秒更新一次，精确度更低
- 每个Redis对象都会有一个lru属性，保存了对象最后一次被命令访问的时间
- 当服务器要计算一个数据库键的空转时间时，会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间

## 3. 更新服务器每秒执行命令数

- trackOperationsPerSecond函数会以每100毫秒一次的频率执行，以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量，可以通过INFO status命令的instantaneous_ops_per_sec域查看
- 会根据ops_sec_last_sample_time记录的上一次抽样时间和服务器当前的时间，以及ops_sec_last_sample_ops记录的上一次抽样的已执行命令数量和服务器当前的已执行命令数量，计算出两个trackOperationsPerSecond调用之间，服务器平均每一毫秒处理了多少命令请求，然后乘以1000，并把这个估计值作为新的数组项放进ops_sec_samples环形数组中
- INFO命令得到的结果是环形数组中所有值的平均值

## 4. 更新服务器内存峰值记录

- stat_peak_memory属性记录了服务器的内存峰值大小
- 每次执行serverCron函数时会比较服务器当前使用的内存数量与stat_peak_memory记录的值，记录较大者
- INFO memory命令的used_memory_peak和used_memory_peak_human查看

## 5. 处理SIGTERM信号

- 在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个函数会在服务器接到SIGTERM信号时打开服务器状态中的shutdown_asap标志
- 每次执行serverCron函数时会检查shutdown_asap的值，为1则关闭服务器，为0不做动作
- 服务器在关闭自身之前会进行RDB持久化操作，这就是拦截SIGTERM的原因，不能一接到信号就关闭

## 6. 管理客户端资源

- serverCron函数每次执行时都会调用clientsCron函数，对一定数量的客户端进行以下两个操作
  - 如果客户端与服务端之间的连接已经超时，那么程序释放这个客户端
  - 如果客户端在上一次执行命令请求后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，防止客户端的输入缓冲区耗费了过多的内存

## 7. 管理数据库资源

- serverCron函数每次执行时都会调用databasesCron函数，会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作

## 8. 执行被延迟的BGREWRITEAOF

- 在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后
- 服务器的aof_rewrite_scheduled标识记录了是否被延迟

## 9. 检查持久化操作的运行状态

- 服务器状态使用rbd_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID
- 每次执行serverCron函数时,只要这两个其中一个属性的值不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程
  - 如果有信号到达，那么表示新的RDB文件已经生成完毕或者AOF文件重写完毕，需要进行替换操作
  - 如果没有，表示持久化操作未完成，程序不做动作
- 如果两者属性都为-1，则执行以下三个检查
  - 查看是否有BGREWRITEAOF被延迟了，如果有，开始一次新的BGREWRITEAOF操作
  - 检查服务器的自动保存条件是否已经被满足，如果条件被满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGSAVE操作
  - 检查服务器设置的AOF重写条件是否已经被满足，如果条件被满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGREWRITEAOF操作

## 10. 将AOF缓冲区中的内容写入到AOF文件

- 如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写入的数据，那么serverCron函数会调用相应的程序，将AOF缓冲区的内容写入到AOF文件里面

## 11. 关闭异步客户端

- 关闭那么输出缓冲区大小超出限制的客户端

## 12. 增加cronloops计数器的值

- 服务器状态的cronloops属性记录了serverCron函数执行的次数，每执行一次加一
- 作用是 在复制模块中实现"每执行serverCron函数N次就执行一次指定代码"的功能

# 初始化服务器

- 由initServerConfig函数完成

## 初始化服务器状态结构

- 创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值
- 设置服务器的运行ID
- 设置服务器的默认运行频率
- 设置服务器的默认配置文件路径
- 设置服务器的运行架构
- 设置服务器的默认端口号
- 设置服务器的默认RDB持久化条件和AOF持久化条件
- 初始化服务器的LRU时钟
- 创建命令表

## 载入配置结构

- 可以通过给定配置参数或者指定配置文件来修改服务器的默认配置

## 初始化服务器数据结构

- 为部分数据结构分配内存，并在有需要时，为这些数据结构设置或者关联初始值

## 还原数据库状态

- 载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态

## 执行时间循环