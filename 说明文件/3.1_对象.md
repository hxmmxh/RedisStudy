# 对象

- [对象](#对象)
  - [1. 简介](#1-简介)
  - [2. 对象的类型与编码](#2-对象的类型与编码)
    - [2.1 类型](#21-类型)
    - [2.2 编码和底层实现](#22-编码和底层实现)
  - [3. 字符串对象](#3-字符串对象)
    - [3.1 embstr编码](#31-embstr编码)
    - [3.2 编码的转换](#32-编码的转换)
    - [3.3 字符串命令的实现](#33-字符串命令的实现)
  - [4. 列表对象](#4-列表对象)
  - [5. 哈希对象](#5-哈希对象)
  - [6. 集合对象](#6-集合对象)
  - [7. 有序集合对象](#7-有序集合对象)
  - [8. 其他特性](#8-其他特性)
    - [8.1 类型检查与命令多态](#81-类型检查与命令多态)
    - [8.2 内存回收](#82-内存回收)
    - [8.3 对象共享](#83-对象共享)
    - [8.4 空转时长](#84-空转时长)
  - [9. 总结](#9-总结)


## 1. 简介

- 共5种类型：字符串对象、列表对象、哈希对象、集合对象和有序集合对象
- 特性：
  1. 可以根据对象的类型来判断一个对象是否可以执行给定的命令。
  2. 可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率，极大地提升了 Redis 的灵活性和效率
  3. 实现了基于引用计数技术的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放
  4. 通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。
  5. 带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。

## 2. 对象的类型与编码

- Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）
- 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种
- 每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性

```c
typedef struct redisObject
{
    unsigned type : 4;             // 类型
    unsigned encoding : 4;         // 编码
    unsigned lru : REDIS_LRU_BITS; // 对象最后一次被访问的时间
    int refcount;                  // 引用计数
    void *ptr;                     // 指向实际值的指针
} robj;
```

### 2.1 类型

- 对象的 type 属性记录了对象的类型， 这个属性的值可以是下表列出的常量的其中一个。
    |type属性|对象的名称|TYPE命令的输出
    |----|-----|----|
    |REDIS_STRING|字符串对象|"string"
    |REDIS_LIST|列表对象|"list"
    |REDIS_HASH|哈希对象|"hash"
    |REDIS_SET|集合对象|"set"
    |REDIS_ZSET|有序集合对象|"zset"
- 对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型
  
### 2.2 编码和底层实现

- ptr 指针指向对象的底层实现数据结构
- encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现，可以是下表列出的常量的其中一个

编码常量|编码所对应的底层数据结构|OBJECT ENCODING 命令
|----|-----|------|
REDIS_ENCODING_INT|long 类型的整数|"int"
REDIS_ENCODING_EMBSTR|embstr 编码的简单动态字符串|"embstr"
REDIS_ENCODING_RAW|简单动态字符串|"raw"
REDIS_ENCODING_HT|字典|"hashtable"
REDIS_ENCODING_LINKEDLIST|双端链表|"linkedlist"
REDIS_ENCODING_ZIPLIST|压缩列表|"ziplist"
REDIS_ENCODING_INTSET|整数集合|"intset"
REDIS_ENCODING_SKIPLIST|跳跃表和字典|"skiplist"

- 每种类型的对象都至少使用了两种不同的编码，下面列出了每种类型的对象可以使用的编码。
- 使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码

类型|编码|对象
|----|-----|----|
REDIS_STRING|REDIS_ENCODING_INT|使用整数值实现的字符串对象。
REDIS_STRING|REDIS_ENCODING_EMBSTR|使用 embstr 编码的简单动态字符串实现的字符串对象。
REDIS_STRING|REDIS_ENCODING_RAW|使用简单动态字符串实现的字符串对象。
|----|-----|----|
REDIS_LIST|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的列表对象。
REDIS_LIST|REDIS_ENCODING_LINKEDLIST|使用双端链表实现的列表对象。
|----|-----|----|
REDIS_HASH|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的哈希对象。
REDIS_HASH|REDIS_ENCODING_HT|使用字典实现的哈希对象。
|----|-----|----|
REDIS_SET|REDIS_ENCODING_INTSET|使用整数集合实现的集合对象。
REDIS_SET|REDIS_ENCODING_HT|使用字典实现的集合对象。
|----|-----|----|
REDIS_ZSET|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的有序集合对象。
REDIS_ZSET|REDIS_ENCODING_SKIPLIST|使用跳跃表和字典实现的有序集合对象。

## 3. 字符串对象

- 字符串对象的编码可以是 int 、 raw 或者 embstr 。
- 如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int
  - Redis还有共享对象，值在0-10000范围内的整数有共享的字符串对象，直接从共享对象里返回，可以避免进行内存分配 
  - 看源代码发现，不能用long表示的整数都用raw编码了
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。
- 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。在有需要的时候， 程序会将保存在字符串对象里面的字符串值转换回浮点数值， 执行某些操作， 然后再将执行操作所得的浮点数值转换回字符串值， 并继续保存在字符串对象里面
  
  
  
值|编码
|----|-----|
可以用 long 类型保存的整数。|int
可以用 long double 类型保存的浮点数。|embstr 或者 raw
字符串值， 或者因为长度太大而没办法用 long 类型表示的整数， 又或者因为长度太大而没办法用 long double 类型表示的浮点数。| embstr 或者 raw

### 3.1 embstr编码
- embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构
- embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的， 但使用 embstr 编码的字符串对象来保存短字符串值有以下好处
  - embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。
  - 释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。
  - 因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势
- 为什么这个界线是39
  - embstr是一块连续的内存区域，由redisObject和sdshdr组成。其中redisObject占16个字节，当buf内的字符串长度是39时，sdshdr的大小为8+39+1=48，那一个字节是'\0'。加起来刚好64 
  - redis开始使用jemalloc内存分配器。这个比glibc的malloc要好不少，还省内存。在这里可以简单理解，jemalloc会分配8，16，32，64等字节的内存。embstr最小为16+8+8+1=33，所以最小分配64字节。当字符数小于39时，都会分配64字节。
- 3.2版本之后分界是44
  - 原来的sdshdr改成了sdshdr16，sdshdr32，sdshdr64，里面的unsigned int 变成了uint8_t,uint16_t.。。。（还加了一个char flags）这样更加优化小sds的内存使用。本身就是针对短字符串的embstr自然会使用最小的sdshdr8，而sdshdr8与之前的sdshdr相比正好减少了5个字节（sdsdr8 = uint8_t * 2 + char = 1*2+1 = 3, sdshdr = unsigned int * 2 = 4 * 2 = 8）,所以其能容纳的字符串长度增加了5个字节变成了44.
- 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。

### 3.2 编码的转换
- int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。
- 对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。例如对整数执行追加操作
- 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。

### 3.3 字符串命令的实现


命令|int 编码的实现方法|embstr 编码的实现方法|raw 编码的实现方法
|----|-----|----|--|
SET	|使用 int 编码保存值。	|使用 embstr 编码保存值。	|使用 raw 编码保存值。
GET	|拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。|	直接向客户端返回字符串值。|	直接向客户端返回字符串值。
APPEND	|将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。	|将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。	|调用 sdscatlen 函数， 将给定字符串追加到现有字符串的末尾。
INCRBYFLOAT	|取出整数值并将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。	|取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。|	取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。
INCRBY	|对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。	|embstr 编码不能执行此命令， 向客户端返回一个错误。	|raw 编码不能执行此命令， 向客户端返回一个错误。
DECRBY	|对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。	|embstr 编码不能执行此命令， 向客户端返回一个错误。|	raw 编码不能执行此命令， 向客户端返回一个错误。
STRLEN	|拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。|	调用 sdslen 函数， 返回字符串的长度。	|调用 sdslen 函数， 返回字符串的长度。
SETRANGE|	将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。	|将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。|	将字符串特定索引上的值设置为给定的字符。
GETRANGE|	拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。	|直接取出并返回字符串指定索引上的字符。|	直接取出并返回字符串指定索引上的字符。


## 4. 列表对象
- 列表对象的编码可以是 ziplist 或者 linkedlist 
  - ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素
  - linkedlist 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素。
- 当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码，不能满足这两个条件的列表对象需要使用 linkedlist 编码。
  - 列表对象保存的所有字符串元素的长度都小于 64 字节；
  - 列表对象保存的元素数量小于 512 个；
  - 以上两个条件的上限值是可以修改的， 具体请看配置文件中 list-max-ziplist-value 选项和 list-max-ziplist-entries 
- 常见命令的实现
  命令|ziplist 编码的实现方法|linkedlist 编码的实现方法
  |--|---|-----|
  LPUSH	|调用 ziplistPush 函数， 将新元素推入到压缩列表的表头。|	调用 listAddNodeHead 函数， 将新元素推入到双端链表的表头。
  RPUSH|	调用 ziplistPush 函数， 将新元素推入到压缩列表的表尾。|	调用 listAddNodeTail 函数， 将新元素推入到双端链表的表尾。
  LPOP	|调用 ziplistIndex 函数定位压缩列表的表头节点， 在向用户返回节点所保存的元素之后， 调用 ziplistDelete 函数删除表头节点。	|调用 listFirst 函数定位双端链表的表头节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表头节点。
  RPOP	|调用 ziplistIndex 函数定位压缩列表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 ziplistDelete 函数删除表尾节点。	|调用 listLast 函数定位双端链表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表尾节点。
  LINDEX	|调用 ziplistIndex 函数定位压缩列表中的指定节点， 然后返回节点所保存的元素。	|调用 listIndex 函数定位双端链表中的指定节点， 然后返回节点所保存的元素。
  LLEN	|调用 ziplistLen 函数返回压缩列表的长度。|	调用 listLength 函数返回双端链表的长度。
  LINSERT|	插入新节点到压缩列表的表头或者表尾时， 使用 ziplistPush 函数； 插入新节点到压缩列表的其他位置时， 使用 ziplistInsert 函数。	|调用 listInsertNode 函数， 将新节点插入到双端链表的指定位置。
  LREM	|遍历压缩列表节点， 并调用 ziplistDelete 函数删除包含了给定元素的节点。|	遍历双端链表节点， 并调用 listDelNode 函数删除包含了给定元素的节点。
  LTRIM	|调用 ziplistDeleteRange 函数， 删除压缩列表中所有不在指定索引范围内的节点。|	遍历双端链表节点， 并调用 listDelNode 函数删除链表中所有不在指定索引范围内的节点。
  LSET	|调用 ziplistDelete 函数， 先删除压缩列表指定索引上的现有节点， 然后调用 ziplistInsert 函数， 将一个包含给定元素的新节点插入到相同索引上面。|	调用 listIndex 函数， 定位到双端链表指定索引上的节点， 然后通过赋值操作更新节点的值。


## 5. 哈希对象
- 哈希对象的编码可以是 ziplist 或者 hashtable
  - ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾
    - 保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；
    - 先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向
  - hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存
    - 字典的每个键都是一个字符串对象， 对象中保存了键值对的键；
    - 字典的每个值都是一个字符串对象， 对象中保存了键值对的值。
- 哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：
  - 哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；
  - 哈希对象保存的键值对数量小于 512 个
  - 这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明
- 常见命令的实现
  
命令|	ziplist 编码实现方法	|hashtable 编码的实现方法
 |--|---|-----|
HSET|	首先调用 ziplistPush 函数， 将键推入到压缩列表的表尾， 然后再次调用 ziplistPush 函数， 将值推入到压缩列表的表尾。|	调用 dictAdd 函数， 将新节点添加到字典里面。
HGET|	首先调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 然后调用 ziplistNext 函数， 将指针移动到键节点旁边的值节点， 最后返回值节点。|	调用 dictFind 函数， 在字典中查找给定键， 然后调用 dictGetVal 函数， 返回该键所对应的值。
HEXISTS	|调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。	|调用 dictFind 函数， 在字典中查找给定键， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。
HDEL|调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 然后将相应的键节点、 以及键节点旁边的值节点都删除掉。|	调用 dictDelete 函数， 将指定键所对应的键值对从字典中删除掉。
HLEN|	调用 ziplistLen 函数， 取得压缩列表包含节点的总数量， 将这个数量除以 2 ， 得出的结果就是压缩列表保存的键值对的数量。|	调用 dictSize 函数， 返回字典包含的键值对数量， 这个数量就是哈希对象包含的键值对数量。
HGETALL|	遍历整个压缩列表， 用 ziplistGet 函数返回所有键和值（都是节点）。|	遍历整个字典， 用 dictGetKey 函数返回字典的键， 用 dictGetVal 函数返回字典的值。
## 6. 集合对象

- 集合对象的编码可以是 intset 或者 hashtable 
  - intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。
  - hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 
- 当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码，否则使用 hashtable 编码。
  - 集合对象保存的所有元素都是整数值；
  - 集合对象保存的元素数量不超过 512 个(由配置文件中的set-max-intset-entries决定)
- 常见命令的实现
  命令|intset 编码的实现方法|hashtable 编码的实现方法
  |--|---|-----|
  SADD|调用 intsetAdd 函数， 将所有新元素添加到整数集合里面。|调用 dictAdd ， 以新元素为键， NULL 为值， 将键值对添加到字典里面。
  SCARD|调用 intsetLen 函数， 返回整数集合所包含的元素数量， 这个数量就是集合对象所包含的元素数量。|调用 dictSize 函数， 返回字典所包含的键值对数量， 这个数量就是集合对象所包含的元素数量。
  SISMEMBER|调用 intsetFind 函数， 在整数集合中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。|调用 dictFind 函数， 在字典的键中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。
  SMEMBERS|遍历整个整数集合， 使用 intsetGet 函数返回集合元素。|遍历整个字典， 使用 dictGetKey 函数返回字典的键作为集合元素。
  SRANDMEMBER	|调用 intsetRandom 函数， 从整数集合中随机返回一个元素。|	调用 dictGetRandomKey 函数， 从字典中随机返回一个字典键。
  SPOP	|调用 intsetRandom 函数， 从整数集合中随机取出一个元素， 在将这个随机元素返回给客户端之后， 调用 intsetRemove 函数， 将随机元素从整数集合中删除掉。|	调用 dictGetRandomKey 函数， 从字典中随机取出一个字典键， 在将这个随机字典键的值返回给客户端之后， 调用 dictDelete 函数， 从字典中删除随机字典键所对应的键值对。
  SREM	|调用 intsetRemove 函数， 从整数集合中删除所有给定的元素。	|调用 dictDelete 函数， 从字典中删除所有键为给定元素的键值对。

## 7. 有序集合对象
- 有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数
- 有序集合的编码可以是 ziplist 或者 skiplist 
  - ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。
    - 压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。
  - skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典dict和一个跳跃表zsl
    - zsl 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作
    - dict 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值
    - 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。
- 为什么有序集合需要同时使用跳跃表和字典来实现？  
  - 在理论上来说， 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现， 但无论单独使用字典还是跳跃表， 在性能上对比起同时使用字典和跳跃表都会有所降低。  
  - 举个例子， 如果我们只使用字典来实现有序集合， 那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留， 但是， 因为字典以无序的方式来保存集合元素， 所以每次在执行范围型操作 —— 比如 ZRANK 、 ZRANGE 等命令时， 程序都需要对字典保存的所有元素进行排序， 完成这种排序需要至少 O(N \log N) 时间复杂度， 以及额外的 O(N) 内存空间 （因为要创建一个数组来保存排序后的元素）。  
  - 另一方面， 如果我们只使用跳跃表来实现有序集合， 那么跳跃表执行范围型操作的所有优点都会被保留， 但因为没有了字典， 所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(\log N) 。
  - 因为以上原因， 为了让有序集合的查找和范围型操作都尽可能快地执行， Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。
- 当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：
  - 有序集合保存的元素数量小于 128 个；
  - 有序集合保存的所有元素成员的长度都小于 64 字节；
  - 以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 zset-max-ziplist-entries 选项和 zset-max-ziplist-value 选项的说明。
- 常见命令的实现

命令|ziplist 编码的实现方法|zset 编码的实现方法
|--|---|-----|
ZADD|调用 ziplistInsert 函数， 将成员和分值作为两个节点分别插入到压缩列表。|先调用 zslInsert 函数， 将新元素添加到跳跃表， 然后调用 dictAdd 函数， 将新元素关联到字典。
ZCARD|调用 ziplistLen 函数， 获得压缩列表包含节点的数量， 将这个数量除以 2 得出集合元素的数量。|访问跳跃表数据结构的 length 属性， 直接返回集合元素的数量。
ZCOUNT|遍历压缩列表， 统计分值在给定范围内的节点的数量。|遍历跳跃表， 统计分值在给定范围内的节点的数量。
ZRANGE|从表头向表尾遍历压缩列表， 返回给定索引范围内的所有元素。|从表头向表尾遍历跳跃表， 返回给定索引范围内的所有元素。
ZREVRANGE|从表尾向表头遍历压缩列表， 返回给定索引范围内的所有元素。|从表尾向表头遍历跳跃表， 返回给定索引范围内的所有元素。
ZRANK	| 从表头向表尾遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。	| 从表头向表尾遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。
ZREVRANK|从表尾向表头遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。|	从表尾向表头遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。
ZREM|遍历压缩列表， 删除所有包含给定成员的节点， 以及被删除成员节点旁边的分值节点。|遍历跳跃表， 删除所有包含了给定成员的跳跃表节点。 并在字典中解除被删除元素的成员和分值的关联。
ZSCORE|遍历压缩列表， 查找包含了给定成员的节点， 然后取出成员节点旁边的分值节点保存的元素分值|	直接从字典中取出给定成员的分值。

## 8. 其他特性

### 8.1 类型检查与命令多态
- Redis 中用于操作键的命令基本上可以分为两种类型。
  - 其中一种命令可以对任何类型的键执行， 比如说 DEL 命令、 EXPIRE 命令、 RENAME 命令、 TYPE 命令、 OBJECT 命令
  - 而另一种命令只能对特定类型的键执行
- 为了确保只有指定类型的键可以执行某些特定的命令， 在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令
- 类型特定命令所进行的类型检查是通过 redisObject 结构的 type 属性来实现的
- Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据值对象的编码方式， 选择正确的命令实现代码来执行命令。
  - 基于类型的多态: 一个命令可以同时用于处理多种不同类型的键
  - 基于编码的多态: 一个命令可以同时用于处理多种不同编码

### 8.2 内存回收
- 因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收
- 对象的引用计数信息会随着对象的使用状态而不断变化：
  - 在创建一个新对象时， 引用计数的值会被初始化为 1 ；
  - 当对象被一个新程序使用时， 它的引用计数值会被增一；
  - 当对象不再被一个程序使用时， 它的引用计数值会被减一；
  - 当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。
- 修改对象引用计数的 API
  - incrRefCount,	将对象的引用计数值增一。
  - decrRefCount,	将对象的引用计数值增一。
  - resetRefCount, 将对象的引用计数值设置为 0 ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用
  
### 8.3 对象共享
- 在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤
  - 将数据库键的值指针指向一个现有的值对象；
  - 将被共享的值对象的引用计数增一。
- 共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存
- 目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象
- 为什么 Redis 不共享包含字符串的对象？
  - 当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：
  - 如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；
  - 如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；
  - 如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。
  - 因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享
  
### 8.4 空转时长
- redisObject 结构包含的最后一个属性为 lru 属性， 该属性记录了对象最后一次被命令程序访问的时间
- OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的
- 如果服务器打开了 maxmemory 选项， 并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru ， 那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。

## 9. 总结
- Redis 数据库中的每个键值对的键和值都是一个对象。
- Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。
- 服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。
- Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。
- Redis 会共享值为 0 到 9999 的字符串对象。
- 对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间。