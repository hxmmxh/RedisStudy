# 对象

- [对象](#对象)
  - [1. 简介](#1-简介)
  - [2. 对象的类型与编码](#2-对象的类型与编码)
    - [2.1 类型](#21-类型)
    - [2.2 编码和底层实现](#22-编码和底层实现)
  - [3. 字符串对象](#3-字符串对象)
    - [3.1 embstr编码](#31-embstr编码)
    - [3.2 编码的转换](#32-编码的转换)
    - [3.3 字符串命令的实现](#33-字符串命令的实现)
  - [4. 列表对象](#4-列表对象)
  - [5. 哈希对象](#5-哈希对象)
  - [6. 集合对象](#6-集合对象)
  - [7. 有序集合对象](#7-有序集合对象)
  - [8. 其他特性](#8-其他特性)
    - [8.1 类型检查与命令多态](#81-类型检查与命令多态)
    - [8.2 内存回收](#82-内存回收)
    - [8.3 对象共享](#83-对象共享)
    - [8.4 空转时长](#84-空转时长)
  - [9. 总结](#9-总结)


## 1. 简介

- 共5种类型：字符串对象、列表对象、哈希对象、集合对象和有序集合对象
- 特性：
  1. 可以根据对象的类型来判断一个对象是否可以执行给定的命令。
  2. 可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率，极大地提升了 Redis 的灵活性和效率
  3. 实现了基于引用计数技术的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放
  4. 通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。
  5. 带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。

## 2. 对象的类型与编码

- Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）
- 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种
- 每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性
  
### 2.1 类型

- 对象的 type 属性记录了对象的类型， 这个属性的值可以是下表列出的常量的其中一个。
    |type属性|对象的名称|TYPE命令的输出
    |----|-----|----|
    |REDIS_STRING|字符串对象|"string"
    |REDIS_LIST|列表对象|"list"
    |REDIS_HASH|哈希对象|"hash"
    |REDIS_SET|集合对象|"set"
    |REDIS_ZSET|有序集合对象|"zset"
- 对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型
  
### 2.2 编码和底层实现

- ptr 指针指向对象的底层实现数据结构
- encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现，可以是下表列出的常量的其中一个

编码常量|编码所对应的底层数据结构|OBJECT ENCODING 命令
|----|-----|------|
REDIS_ENCODING_INT|long 类型的整数|"int"
REDIS_ENCODING_EMBSTR|embstr 编码的简单动态字符串|"embstr"
REDIS_ENCODING_RAW|简单动态字符串|"raw"
REDIS_ENCODING_HT|字典|"hashtable"
REDIS_ENCODING_LINKEDLIST|双端链表|"linkedlist"
REDIS_ENCODING_ZIPLIST|压缩列表|"ziplist"
REDIS_ENCODING_INTSET|整数集合|"intset"
REDIS_ENCODING_SKIPLIST|跳跃表和字典|"skiplist"

- 每种类型的对象都至少使用了两种不同的编码，下面列出了每种类型的对象可以使用的编码。
- 使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码

类型|编码|对象
|----|-----|----|
REDIS_STRING|REDIS_ENCODING_INT|使用整数值实现的字符串对象。
REDIS_STRING|REDIS_ENCODING_EMBSTR|使用 embstr 编码的简单动态字符串实现的字符串对象。
REDIS_STRING|REDIS_ENCODING_RAW|使用简单动态字符串实现的字符串对象。
|----|-----|----|
REDIS_LIST|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的列表对象。
REDIS_LIST|REDIS_ENCODING_LINKEDLIST|使用双端链表实现的列表对象。
|----|-----|----|
REDIS_HASH|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的哈希对象。
REDIS_HASH|REDIS_ENCODING_HT|使用字典实现的哈希对象。
|----|-----|----|
REDIS_SET|REDIS_ENCODING_INTSET|使用整数集合实现的集合对象。
REDIS_SET|REDIS_ENCODING_HT|使用字典实现的集合对象。
|----|-----|----|
REDIS_ZSET|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的有序集合对象。
REDIS_ZSET|REDIS_ENCODING_SKIPLIST|使用跳跃表和字典实现的有序集合对象。

## 3. 字符串对象

- 字符串对象的编码可以是 int 、 raw 或者 embstr 。
- 如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。
- 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。在有需要的时候， 程序会将保存在字符串对象里面的字符串值转换回浮点数值， 执行某些操作， 然后再将执行操作所得的浮点数值转换回字符串值， 并继续保存在字符串对象里面
  
  
值|编码
|----|-----|
可以用 long 类型保存的整数。|int
可以用 long double 类型保存的浮点数。|embstr 或者 raw
字符串值， 或者因为长度太大而没办法用 long 类型表示的整数， 又或者因为长度太大而没办法用 long double 类型表示的浮点数。| embstr 或者 raw

### 3.1 embstr编码
- embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构
- embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的， 但使用 embstr 编码的字符串对象来保存短字符串值有以下好处
  - embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。
  - 释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。
  - 因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势
- 为什么这个界线是39
  - embstr是一块连续的内存区域，由redisObject和sdshdr组成。其中redisObject占16个字节，当buf内的字符串长度是39时，sdshdr的大小为8+39+1=48，那一个字节是'\0'。加起来刚好64 
  - redis开始使用jemalloc内存分配器。这个比glibc的malloc要好不少，还省内存。在这里可以简单理解，jemalloc会分配8，16，32，64等字节的内存。embstr最小为16+8+8+1=33，所以最小分配64字节。当字符数小于39时，都会分配64字节。
- 3.2版本之后分界是44
  - 原来的sdshdr改成了sdshdr16，sdshdr32，sdshdr64，里面的unsigned int 变成了uint8_t,uint16_t.。。。（还加了一个char flags）这样更加优化小sds的内存使用。本身就是针对短字符串的embstr自然会使用最小的sdshdr8，而sdshdr8与之前的sdshdr相比正好减少了5个字节（sdsdr8 = uint8_t * 2 + char = 1*2+1 = 3, sdshdr = unsigned int * 2 = 4 * 2 = 8）,所以其能容纳的字符串长度增加了5个字节变成了44.
- 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。

### 3.2 编码的转换
- int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。
- 对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。例如对整数执行追加操作
- 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。

### 3.3 字符串命令的实现


命令|int 编码的实现方法|embstr 编码的实现方法|raw 编码的实现方法
|----|-----|----|--|
SET	|使用 int 编码保存值。	|使用 embstr 编码保存值。	|使用 raw 编码保存值。
GET	|拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。|	直接向客户端返回字符串值。|	直接向客户端返回字符串值。
APPEND	|将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。	|将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。	|调用 sdscatlen 函数， 将给定字符串追加到现有字符串的末尾。
INCRBYFLOAT	|取出整数值并将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。	|取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。|	取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。
INCRBY	|对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。	|embstr 编码不能执行此命令， 向客户端返回一个错误。	|raw 编码不能执行此命令， 向客户端返回一个错误。
DECRBY	|对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。	|embstr 编码不能执行此命令， 向客户端返回一个错误。|	raw 编码不能执行此命令， 向客户端返回一个错误。
STRLEN	|拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。|	调用 sdslen 函数， 返回字符串的长度。	|调用 sdslen 函数， 返回字符串的长度。
SETRANGE|	将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。	|将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。|	将字符串特定索引上的值设置为给定的字符。
GETRANGE|	拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。	|直接取出并返回字符串指定索引上的字符。|	直接取出并返回字符串指定索引上的字符。


## 4. 列表对象
- 列表对象的编码可以是 ziplist 或者 linkedlist 
  - ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素
  - linkedlist 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素。
- 当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码，不能满足这两个条件的列表对象需要使用 linkedlist 编码。
  - 列表对象保存的所有字符串元素的长度都小于 64 字节；
  - 列表对象保存的元素数量小于 512 个；
  - 以上两个条件的上限值是可以修改的， 具体请看配置文件中 list-max-ziplist-value 选项和 list-max-ziplist-entries 
- 常见命令的实现
  命令|ziplist 编码的实现方法|linkedlist 编码的实现方法
  |--|---|-----|
  LPUSH	|调用 ziplistPush 函数， 将新元素推入到压缩列表的表头。|	调用 listAddNodeHead 函数， 将新元素推入到双端链表的表头。
  RPUSH|	调用 ziplistPush 函数， 将新元素推入到压缩列表的表尾。|	调用 listAddNodeTail 函数， 将新元素推入到双端链表的表尾。
  LPOP	|调用 ziplistIndex 函数定位压缩列表的表头节点， 在向用户返回节点所保存的元素之后， 调用 ziplistDelete 函数删除表头节点。	|调用 listFirst 函数定位双端链表的表头节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表头节点。
  RPOP	|调用 ziplistIndex 函数定位压缩列表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 ziplistDelete 函数删除表尾节点。	|调用 listLast 函数定位双端链表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表尾节点。
  LINDEX	|调用 ziplistIndex 函数定位压缩列表中的指定节点， 然后返回节点所保存的元素。	|调用 listIndex 函数定位双端链表中的指定节点， 然后返回节点所保存的元素。
  LLEN	|调用 ziplistLen 函数返回压缩列表的长度。|	调用 listLength 函数返回双端链表的长度。
  LINSERT|	插入新节点到压缩列表的表头或者表尾时， 使用 ziplistPush 函数； 插入新节点到压缩列表的其他位置时， 使用 ziplistInsert 函数。	|调用 listInsertNode 函数， 将新节点插入到双端链表的指定位置。
  LREM	|遍历压缩列表节点， 并调用 ziplistDelete 函数删除包含了给定元素的节点。|	遍历双端链表节点， 并调用 listDelNode 函数删除包含了给定元素的节点。
  LTRIM	|调用 ziplistDeleteRange 函数， 删除压缩列表中所有不在指定索引范围内的节点。|	遍历双端链表节点， 并调用 listDelNode 函数删除链表中所有不在指定索引范围内的节点。
  LSET	|调用 ziplistDelete 函数， 先删除压缩列表指定索引上的现有节点， 然后调用 ziplistInsert 函数， 将一个包含给定元素的新节点插入到相同索引上面。|	调用 listIndex 函数， 定位到双端链表指定索引上的节点， 然后通过赋值操作更新节点的值。


## 5. 哈希对象

## 6. 集合对象

- 集合对象的编码可以是 intset 或者 hashtable 
  - intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。
  - hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 
- 当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码，否则使用 hashtable 编码。
  - 集合对象保存的所有元素都是整数值；
  - 集合对象保存的元素数量不超过 512 个(由配置文件中的set-max-intset-entries决定)
- 常见命令的实现
  命令|intset 编码的实现方法|hashtable 编码的实现方法
  |--|---|-----|
  SADD|调用 intsetAdd 函数， 将所有新元素添加到整数集合里面。|调用 dictAdd ， 以新元素为键， NULL 为值， 将键值对添加到字典里面。
  SCARD|调用 intsetLen 函数， 返回整数集合所包含的元素数量， 这个数量就是集合对象所包含的元素数量。|调用 dictSize 函数， 返回字典所包含的键值对数量， 这个数量就是集合对象所包含的元素数量。
  SISMEMBER|调用 intsetFind 函数， 在整数集合中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。|调用 dictFind 函数， 在字典的键中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。
  SMEMBERS|遍历整个整数集合， 使用 intsetGet 函数返回集合元素。|遍历整个字典， 使用 dictGetKey 函数返回字典的键作为集合元素。
  SRANDMEMBER	|调用 intsetRandom 函数， 从整数集合中随机返回一个元素。|	调用 dictGetRandomKey 函数， 从字典中随机返回一个字典键。
  SPOP	|调用 intsetRandom 函数， 从整数集合中随机取出一个元素， 在将这个随机元素返回给客户端之后， 调用 intsetRemove 函数， 将随机元素从整数集合中删除掉。|	调用 dictGetRandomKey 函数， 从字典中随机取出一个字典键， 在将这个随机字典键的值返回给客户端之后， 调用 dictDelete 函数， 从字典中删除随机字典键所对应的键值对。
  SREM	|调用 intsetRemove 函数， 从整数集合中删除所有给定的元素。	|调用 dictDelete 函数， 从字典中删除所有键为给定元素的键值对。




## 7. 有序集合对象

## 8. 其他特性

### 8.1 类型检查与命令多态

### 8.2 内存回收

### 8.3 对象共享

### 8.4 空转时长



## 9. 总结