AOF持久化
-----------------------------------------

- [简介](#简介)
- [AOF持久化的实现](#aof持久化的实现)
  - [命令追加](#命令追加)
  - [AOF文件的写入与同步](#aof文件的写入与同步)
- [AOF文件的载入与数据还原](#aof文件的载入与数据还原)
- [AOF重写](#aof重写)
  - [AOF重写的实现](#aof重写的实现)
  - [AOF后台重写](#aof后台重写)
- [重点回顾](#重点回顾)
# 简介

- AOF，Append Only File
- RDB持久化通过保存数据库中的键值对来记录数据库状态的不同
- AOF持久化通过保存Redis服务器所执行的写命令来记录数据库状态
- 被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，是纯文本格式，可以直接打开一个AOF文件，观察里面的内容
- 服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭时的数据库状态

# AOF持久化的实现

- AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。

## 命令追加

- 当 AOF 持久化功能处于打开状态时， 服务器在执行完一个写命令之后， 会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾

## AOF文件的写入与同步

- Redis 的服务器进程就是一个事件循环（loop）， 这个循环中的文件事件负责接收客户端的命令请求， 以及向客户端发送命令回复， 而时间事件则负责执行像 serverCron 函数这样需要定时运行的函数。
- 因为服务器在处理文件事件时可能会执行写命令， 使得一些内容被追加到 aof_buf 缓冲区里面， 所以在服务器每次结束一个事件循环之前， 它都会调用 flushAppendOnlyFile 函数， 考虑是否需要将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件里面
- flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定， 各个不同值产生的行为如下表所示。如果用户没有主动为 appendfsync 选项设置值， 那么 appendfsync 选项的默认值为 everysec 。
  - 写入是调用write写入内存缓冲区
  - 同步是flush，将缓冲区中的数据写入到硬盘中

appendfsync 选项的值|flushAppendOnlyFile 函数的行为
|-----|-------|
always|将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件。
everysec|将 aof_buf 缓冲区中的所有内容写入到 AOF 文件， 如果上次同步 AOF 文件的时间距离现在超过一秒钟， 那么再次对 AOF 文件进行同步， 并且这个同步操作是由一个线程专门负责执行的。
no|将 aof_buf 缓冲区中的所有内容写入到 AOF 文件， 但并不对 AOF 文件进行同步， 何时同步由操作系统来决定。



# AOF文件的载入与数据还原

- 因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态
- 详细步骤如下
  1. 创建一个不带网络连接的伪客户端
  2. 从AOF文件中分析并读取出一条写命令
  3. 使用伪客户端执行被读书的写命令
  4. 重复执行步骤2，3，直到所有写命令都处理完毕

# AOF重写

- 因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大。
- 为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能，创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，体积要小得多

## AOF重写的实现

- 实际上AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的
- 首先，从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令
- 为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表，哈希，集合和有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了REDIS_AOF_REWRITE_ITEMS_PER_CMD（默认设为64）,那么重写程序将使用多条命令来记录键的值

## AOF后台重写

- Redis服务器使用单个线程来处理命令请求，如果由服务器直接调用aof_rewrite，会造成线程被长时间阻塞，服务器在这期间将无法处理客户端发来的命令请求
- 所以一般AOF重写程序会被放到子进程里执行
  - 子进程进行AOF重写期键，服务器进程可以继续处理命令请求
  - 子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性
  - 出现的问题：因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写的dAOF文件所保存的数据库状态不一致
  - 解决问题：设置一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区
- 当子进程完成AOF重写工作后，会像父进程发送信号，父进程在接到该信号后，会调用一个信号处理函数，执行以下工作
  - 将AOF重写缓冲区中的所有内容写入到新的AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致
  - 对新的AOF文件进行改名，原子地覆盖现有的AOF文件
- 在整个AOF后台重写过程中，只有信号处理函数执行时会被服务器进程造成阻塞，将AOF重写对服务器性能造成的影响降到最低

# 重点回顾

- AOF 文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。
- AOF 文件中的所有命令都以 Redis 命令请求协议的格式保存。
- 命令请求会先保存到 AOF 缓冲区里面， 之后再定期写入并同步到 AOF 文件。
- appendfsync 选项的不同值对 AOF 持久化功能的安全性、以及 Redis 服务器的性能有很大的影响。
- 服务器只要载入并重新执行保存在 AOF 文件中的命令， 就可以还原数据库本来的状态。
- AOF 重写可以产生一个新的 AOF 文件， 这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样， 但体积更小。
- AOF 重写是一个有歧义的名字， 该功能是通过读取数据库中的键值对来实现的， 程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。
- 在执行 BGREWRITEAOF 命令时， Redis 服务器会维护一个 AOF 重写缓冲区， 该缓冲区会在子进程创建新 AOF 文件的期间， 记录服务器执行的所有写命令。 当子进程完成创建新 AOF 文件的工作之后， 服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾， 使得新旧两个 AOF 文件所保存的数据库状态一致。 最后， 服务器用新的 AOF 文件替换旧的 AOF 文件， 以此来完成 AOF 文件重写操作