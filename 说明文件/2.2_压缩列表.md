# 压缩列表


## 简介

## 应用

- 列表键、哈希键和有序集合的底层实现之一
- 当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。
- 当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做哈希键的底层实现。
- 有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）

## 实现
- 压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。
- 一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值，整数值被保存为实际的整数，而不是字符数组。 字节数组可以是以下三种长度的其中一种,整数值则可以是以下六种长度的其中一种.所有整数都表示为小端字节序。
  - 长度小于等于 63 （2^{6}-1）字节的字节数组；
  - 长度小于等于 16383 （2^{14}-1） 字节的字节数组；
  - 长度小于等于 4294967295 （2^{32}-1）字节的字节数组
  - 4 位长，介于 0 至 12 之间的无符号整数；
  - 1 字节长的有符号整数；
  - 3 字节长的有符号整数；
  - int16_t 类型整数；
  - int32_t 类型整数；
  - int64_t 类型整数
- 压缩列表并没有一个特定的结构，用一个unsigned char *指针表示，其内部结构如下
  - `<zlbytes><zltail><zllen><entry><entry><zlend>`
  - uint32_t zlbytes: 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用
  - uint32_t zltail: 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址
  - uint16_t zllen: 记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。
  - entry: 压缩列表包含的各个节点，节点的长度由节点保存的内容决定
  - uint8_t zlend: 特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。
  - 下面是ziplist的实例图
```
空白 ziplist 示例图

area        |<---- ziplist header ---->|<-- end -->|

size          4 bytes   4 bytes 2 bytes  1 byte
            +---------+--------+-------+-----------+
component   | zlbytes | zltail | zllen | zlend     |
            |         |        |       |           |
value       |  1011   |  1010  |   0   | 1111 1111 |
            +---------+--------+-------+-----------+
                                       ^
                                       |
                               ZIPLIST_ENTRY_HEAD
                                       &
address                        ZIPLIST_ENTRY_TAIL
                                       &
                               ZIPLIST_ENTRY_END

非空 ziplist 示例图

area        |<---- ziplist header ---->|<----------- entries ------------->|<-end->|

size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte
            +---------+--------+-------+--------+--------+--------+--------+-------+
component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |
            +---------+--------+-------+--------+--------+--------+--------+-------+
                                       ^                          ^        ^
address                                |                          |        |
                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END
                                                                  |
                                                        ZIPLIST_ENTRY_TAIL
```
- 压缩列表节点由3部分构成，内部结构如下
  - `<previous_entry_length><encoding><content>`
  - previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。
    - revious_entry_length 属性的长度可以是 1 字节(0-255）或者 5 字节：
    - 如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面
    - 如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。
    - 为什么被设置为0xFE，是为了区别于代表zlend的0xFF。这种设计会使一个有效节点的开头一定不会是0XFF，方便在正序遍历节点时判断是否到达末尾。
    - previous_entry_length 属性的长度为 5 字节时节点的长度也可能小于254字节，产生的原因见连锁更新的最后一条
    - 因为节点的 previous_entry_length 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。可以利用它实现从表尾向表头的遍历操作
  -  encoding 属性记录了节点的 content 属性所保存数据的类型以及长度
     - 一字节、两字节或者五字节长，值的最高位为00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录
     - 一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；
     - 下表记录了所有可用的字节数组编码，而下下表则记录了所有可用的整数编码。表格中的下划线 _ 表示留空，而b、x等变量则代表实际的二进制数据，为了方便阅读，多个字节之间用空格隔开。
     - 注意4位整数编码时，v表示成11110001+v
  - content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定 
- 连锁更新
  - 由于插入或删除元素导致一字节的previous_entry_length无法保存前一节点长度，需要扩展到5自己，并引发的连续多次空间扩展操作
  - 连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2)。
  - ziplistPush、ziplistInsert、ziplistDelete 和 ziplistDeleteRange 四个函数都有可能会引发连锁更新
  - 反过来说，因为节点的长度变小而引起的连续缩小也是可能出现的，不过，为了避免扩展-缩小-扩展-缩小这样的情况反复出现（flapping，抖动），我们不处理这种情况，而是任由 prevlen 比所需的长度更长
  
编码|编码长度|content 属性保存的值
|---|---|-----|
00bbbbbb|1 字节|长度小于等于 63 字节的字节数组。
01bbbbbb xxxxxxxx|2 字节|长度小于等于 16383 字节的字节数组。
10______ aaaaaaaa bbbbbbbb cccccccc dddddddd|5 字节|长度小于等于 4294967295 的字节数组。
|----|---|----|
11000000|1 字节|int16_t 类型的整数。
11010000|1 字节|int32_t 类型的整数。
11100000|1 字节|int64_t 类型的整数。
11110000|1 字节|24 位有符号整数。
11111110|1 字节|8 位有符号整数。
1111xxxx|1 字节|使用这一编码的节点没有相应的content,编码本身的 xxxx 四个位已经保存了一个介于 0 和 12(0x1100) 之间的值
 
## API

函数|作用|算法复杂度
|----|---|----|
ziplistNew|创建一个新的压缩列表。|O(1)
ziplistPush|创建一个包含给定值的新节点， 并将这个新节点添加到压缩列表的表头或者表尾。|平均 O(N)最坏 O(N^2) 。
ziplistInsert|将包含给定值的新节点插入到给定节点之后。|平均 O(N) ，最坏 O(N^2) 。
ziplistIndex|返回压缩列表给定索引上的节点。|O(N)
ziplistFind|在压缩列表中查找并返回包含了给定值的节点。|因为节点的值可能是一个字节数组， 所以检查节点值和给定值是否相同的复杂度为 O(N) ， 而查找整个列表的复杂度则为 O(N^2) 。
ziplistNext|返回给定节点的下一个节点。|	O(1)
ziplistPrev|返回给定节点的前一个节点。|	O(1)
ziplistGet|获取给定节点所保存的值。|O(1)
ziplistDelete|从压缩列表中删除给定的节点。|平均 O(N) ，最坏 O(N^2) 。
ziplistDeleteRange|删除压缩列表在给定索引上的连续多个节点。|平均 O(N) ，最坏 O(N^2) 。
ziplistBlobLen|返回压缩列表目前占用的内存字节数。|O(1)
ziplistLen|返回压缩列表目前包含的节点数量。|节点数量小于 65535 时 O(1) ， 大于 65535 时 O(N) 。
